"""Extractor roles for information extraction and memory consolidation.

This module defines LLM roles for extracting relevant information from text
and consolidating memory items.
"""
import logging
import os
from enum import Enum
from typing import List
import pydantic

from wemg.agents.roles.base_role import _create_role

logger = logging.getLogger(__name__)
logger.setLevel(os.getenv("LOGGING_LEVEL", "INFO"))


# =============================================================================
# Enums and Constants
# =============================================================================

class SourceType(Enum):
    """Source types for memory provenance tracking."""
    SYSTEM_PREDICTION = "System Prediction"  # Generated by system
    RETRIEVAL = "Retrieval"                  # Retrieved from external sources


# =============================================================================
# Prompts
# =============================================================================

EXTRACT_PROMPT = """You are a meticulous research analyst. Build a comprehensive dossier of information from the provided text that could help answer the question.

Instructions:
1. Question Deconstruction: Identify primary subject, key entities, and specific information sought.
2. Candidate Identification: Identify and quote ALL passages that seem potentially related to the concepts in the question. Be liberal and inclusive in this initial pass; we will filter and refine in the next step.
3. Relevance Evaluation: Assess each quote against criteria (directly answering, contextual, supporting evidence, etc.).
4. Extraction: Extract ALL relevant information verbatim. Add context for clarity but preserve original meaning, make sure each extracted information is self-contained (i.e, each information must be FULLY UNDERSTANDABLE on its own without needing to refer back to the original document, question, or other items) and can be used to answer the question.
5. Final Decision: 'relevant' or 'not_relevant'. Only 'not_relevant' if ZERO related information.
"""

MEMORY_CONSOLIDATION_PROMPT = """You are an expert Memory Consolidation Agent. Your task is to process an input memory (a list of tagged information items) and consolidate it into a refined memory that contains only the information relevant and useful for answering the given question.

## Provenance Tags
- [System Prediction]: System-generated information
- [Retrieval]: Retrieved from external sources

## Instructions
1. Question Analysis: Identify primary subject and key entities
2. Relevance Filtering: Keep directly relevant and supporting items, remove irrelevant
3. Duplicate & Redundancy Removal: Remove exact duplicates (keep [Retrieval] over [System Prediction] if both exist). Merge near-duplicates into single comprehensive items. Remove items whose information is subsumed by other items.
4. Conflict Resolution: [Retrieval] > [System Prediction], specific > general. If unresolvable, merge into an item that notes the conflict
5. Final Consolidation: Each item MUST be self-contained and clear, i.e., understandable without any external context, referencing the original memory, question, or other items

## Rules
- Do NOT invent new information
- REMOVE irrelevant information
- PRESERVE all relevant, non-redundant information
"""


# =============================================================================
# Input/Output Models
# =============================================================================

class ExtractionInput(pydantic.BaseModel):
    question: str = pydantic.Field(..., description="The user's question.")
    raw_data: str = pydantic.Field(..., description="Raw text to analyze.")

    def __str__(self):
        return "\n\n".join(f"{k}:\n{v}" for k, v in self.model_dump().items())


class ExtractionOutput(pydantic.BaseModel):
    information: List[str] = pydantic.Field(..., description="Extracted relevant information.")
    decision: str = pydantic.Field(..., pattern=r"^(relevant|not_relevant)$")


class MemoryItem(pydantic.BaseModel):
    content: str = pydantic.Field(..., description="Self-contained information piece.")
    provenance: SourceType = pydantic.Field(..., pattern=r"^(System Prediction|Retrieval)$")


class MemoryConsolidationInput(pydantic.BaseModel):
    question: str = pydantic.Field(..., description="Question the memory should help answer.")
    memory: str = pydantic.Field(..., description="Raw memory as list of tagged items.")

    def __str__(self):
        return "\n\n".join(f"{k}:\n{v}" for k, v in self.model_dump().items())


class MemoryConsolidationOutput(pydantic.BaseModel):
    consolidated_memory: List[MemoryItem] = pydantic.Field(..., description="Refined memory items.")


# =============================================================================
# Role Classes
# =============================================================================


Extractor = _create_role(
    "extractor",
    EXTRACT_PROMPT,
    ExtractionInput,
    ExtractionOutput,
    "Information extraction role for multi-hop question answering."
)

MemoryConsolidationRole = _create_role(
    "memory_consolidation",
    MEMORY_CONSOLIDATION_PROMPT,
    MemoryConsolidationInput,
    MemoryConsolidationOutput,
    "Memory consolidation role for multi-hop question answering."
)
