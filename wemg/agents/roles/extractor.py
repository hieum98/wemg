"""Extractor roles for information extraction and memory consolidation.

This module defines LLM roles for extracting relevant information from text
and consolidating memory items.
"""
import logging
import os
from enum import Enum
from typing import List
import pydantic

from wemg.agents.roles.base_role import _create_role

logger = logging.getLogger(__name__)
logger.setLevel(os.getenv("LOGGING_LEVEL", "INFO"))


# =============================================================================
# Enums and Constants
# =============================================================================

class SourceType(Enum):
    """Source types for memory provenance tracking."""
    SYSTEM_PREDICTION = "System Prediction"  # Generated by system
    RETRIEVAL = "Retrieval"                  # Retrieved from external sources


# =============================================================================
# Prompts
# =============================================================================

EXTRACT_PROMPT = """You are a meticulous research analyst. Build a comprehensive dossier of information from the provided text that could help answer the question.

Rules:
- Consider both direct and indirect relevant information. An information is considered relevant if it contains any clues that could help answer the question (not necessarily directly answering the question, but providing information that could help answer the question).
- Extracted information must be self-contained and clear, i.e., understandable without any external context, referencing the original memory, question, or other items.

Instructions:
1. Question Deconstruction: Identify primary subject, key entities, and specific information sought.
2. Candidate Identification: Identify and quote ALL passages that seem potentially related to the concepts in the question. Be liberal and inclusive in this initial pass; we will filter and refine in the next step.
3. Relevance Evaluation: Assess each quote against criteria (directly answering, contextual, supporting evidence, etc.).
4. Extraction: Extract ALL relevant information verbatim. Add context for clarity but preserve original meaning, make sure each extracted information is self-contained (i.e, each information must be FULLY UNDERSTANDABLE on its own without needing to refer back to the original document, question, or other items) and can be used to answer the question.
5. Final evaluation: 
    - Examine the extracted information to make sure each information is self-contained. If it is not, rewrite it to make it self-contained.
    - Remove information that is not relevant to the question. The information considers not relevant if and only if it contains ZERO information that could relate to any entity or concept in the question.
    - If the extracted information is relevant, return the extracted information as a list of strings.
    - If the extracted information is not relevant, return an empty list.
"""

MEMORY_CONSOLIDATION_PROMPT = """You are an expert Memory Consolidation Agent. Your task is to process an input memory (a list of tagged information items) and consolidate it into a refined memory that contains only the information relevant and useful for answering the given question. An information is considered relevant and useful if it contains any clues that could help answer the question (not necessarily directly answering the question, but providing information that could help answer the question).

## Provenance Tags
- [System Prediction]: System-generated information
- [Retrieval]: Retrieved from external sources

## Instructions
1. Question Analysis: Identify primary subject and key entities
2. Relevance Evaluation: Assess each information whether it is relevant and useful for answering the question.
3. Duplicate & Redundancy Removal: Remove exact duplicates (keep [Retrieval] over [System Prediction] if both exist). Merge near-duplicates into single comprehensive items. Remove items whose information is subsumed by other items.
4. Conflict Resolution: [Retrieval] > [System Prediction], specific > general. If unresolvable, merge into an item that notes the conflict
5. Final Consolidation: 
    - Each item MUST be self-contained and clear, i.e., understandable without any external context, referencing the original memory, question, or other items
    - Remove information that is not relevant or useful to the question. The information considers not relevant or useful if and only if it contains ZERO information that could relate to any entity or concept in the question.

## Rules
- Do NOT invent new information
- REMOVE irrelevant information
- PRESERVE all relevant, non-redundant information
"""


# =============================================================================
# Input/Output Models
# =============================================================================

class ExtractionInput(pydantic.BaseModel):
    question: str = pydantic.Field(..., description="The user's question.")
    raw_data: str = pydantic.Field(..., description="Raw text to analyze.")

    def __str__(self):
        return "\n\n".join(f"{k}:\n{v}" for k, v in self.model_dump().items())

class ExtractionOutput(pydantic.BaseModel):
    relevant_information: List[str] = pydantic.Field(..., description="Self-contained information that is (directly or indirectly) relevant to the question.")


class MemoryItem(pydantic.BaseModel):
    content: str = pydantic.Field(..., description="Self-contained information piece.")
    provenance: SourceType = pydantic.Field(..., pattern=r"^(System Prediction|Retrieval)$")


class MemoryConsolidationInput(pydantic.BaseModel):
    question: str = pydantic.Field(..., description="Question the memory should help answer.")
    memory: str = pydantic.Field(..., description="Raw memory as list of tagged items.")

    def __str__(self):
        return "\n\n".join(f"{k}:\n{v}" for k, v in self.model_dump().items())


class MemoryConsolidationOutput(pydantic.BaseModel):
    consolidated_memory: List[MemoryItem] = pydantic.Field(..., description="Refined memory items.")


# =============================================================================
# Role Classes
# =============================================================================


Extractor = _create_role(
    "extractor",
    EXTRACT_PROMPT,
    ExtractionInput,
    ExtractionOutput,
    "Information extraction role for multi-hop question answering."
)

MemoryConsolidationRole = _create_role(
    "memory_consolidation",
    MEMORY_CONSOLIDATION_PROMPT,
    MemoryConsolidationInput,
    MemoryConsolidationOutput,
    "Memory consolidation role for multi-hop question answering."
)
